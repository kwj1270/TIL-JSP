표현 언어(Expression Language)-2
=======================
# 2. EL 기초
EL은 일종의 스크립트 언어로 자료 타입, 수치 연산자, 논리 연산자, 비교 연산자 등을 제공한다.     
        
## 2.1. EL의 데이터 타입과 리터럴
EL은 Boolean 타입, 정수 타입, 실수 타입, 문자열 타입 그리고 널 타입의 5가지 타입을 제공하고 있다.     
     
* 불리언(Boolean) 타입 : true와 false가 있다.
* 정수 타입 : 0~9로 이루어진 값을 정수로 사용하고 음수는 ```-```가 붙는다 (long 타입이다.) 
* 실수 타입 : 0~9로 이루어져 있으며, 소수점```.```을 사용할 수 있고,  
3.24e3과 같이 지수형으로 표현 가능하다. EL에서 실수 타입은 double이다.  
* 문자열 타입 : 따옴표(```'```, ```"```)로 둘러싼 문자열. 이스케이프 문자를 지원한다. (String 타입이다.)  
* 널 타입 : null
  
## 2.2. EL의 기본 객체
JSP는 웹 어플리케이션을 구현하는 데 필요한 요청, 응답, 세션 등에 쉽게 접근할 수 있도록 기본 객체를 제공한다.  
JSP는 EL 에서 사용할 수 있는 기본 객체도 제공하고 있다.  
```
pageContext         | pageContext 기본 객체와 동일
pageScope           | pageContext 기본 객체에 저장된 속성의 <속성, 값> 매핑을 저장한 Map 객체
requestScope        | request 기본 객체에 저장된 속성의 <속성, 값> 매핑을 저장한 Map 객체
sessionScope        | session 기본 객체에 저장된 속성의 <속성, 값> 매핑을 저장한 Map 객체
applicationScope    | application 기본 객체에 저장된 속성의 <속성, 값> 매핑을 저장한 Map 객체
param               | 요청 파라미터의 <파라미터 이름, 값> 매핑을 저장한 Map 객체, 파라미터의 값은 String이다.
paramValues         | 요청 파라미터의 <파라미터 이름, 값> 매핑을 저장한 Map 객체, 파라미터의 값은 String[]이다.
header              | 요청 정보의 <헤더이름, 값> 매핑을 저장한 Map 객체, request.getHeader()와 동일
headerValues        | 요청 정보의 <헤더이름, 값> 매핑을 저장한 Map 객체, request.getHeaders()와 동일
cookie              | <쿠키 이름, Cookie> 매핑을 저장한 Map 객체, request.getCookies()로 구한 배열로부터 매핑 생성
initParam           | 초기화 파라미터의 <이름, 값> 매핑을 저장한 Map 객체. application.getInitParameter()와 동일
```   
cookie는 쿠키 이름을 ```Key```로 설정하고 동명의 쿠키 자체를 ```value```로 저장한다고 생각하면 된다.   
위 기본객체들은 단순히 사용하는 것이 아니라 위 기본객체에```.key값```을 입력하면 해당 ```key```의 값을 반환한다.   
   
**LE 기본객체 예시**  
```
<%@ page contentType="text/html; charset=utf-8" %>
<%
    request.setAttribute("name", "김우재");
%>
<html>
<head><title>EL object</title></head>
<body>

요청 URI : ${pageContext.request.requestURI}<br>   // pageContext.getRequest().getRequestURI();
request의 name 속성 : ${requestScope.name}<br>     // request.getAttribute("name");   
code 파라미터 : ${param.code}                      // request.getParameter(code);

</body>
</html>
```
**결과**
```
요청 URI : /chap11/useELObject.jsp
request의 name 속성 : 최범균
code 파라미터 : 
```
우선 위의 예시에서 사용한 3가지 EL 기법을 살펴보면 
  
1. gettter 메서드를 간략하게 줄인다.  
2. getAttribute("값")에서 메서드를 생략하고 값만 넣는다.
3. getParameter("값")에서 메서드를 생략하고 값만 넣는다.  
   
이렇듯 EL은 상황에 따라 메서드의 일부를 생략할지 메서드를 생략하고 값을 쓸지 다르므로 생각하면서 사용하자.  
   
또한, 결과를 보면 code 파라미터 값이 존재하지 않지만, null을 출력하지 않았다.     
이는 EL의 특징으로 EL은 값이 존재하지 않는 경우 아무것도 출력하지 않는다.    
  
그리고 위 예시에 사용된 기본 객체 말고도 앞서 정의한 다른 기본 객체를 사용할 수 있다.  
예를 들면, 이름이 "ID"인 쿠키의 값을 출력하고자 하면 아래와 같이 사용하면 된다.  
```
${cookie.ID.value}
```
EL의 ```cookie``` 기본 객체는 <쿠키이름, Cookie 객체> Map 객체이기에    
```cookie.ID``` 는 이름이 "ID"인 ```Cookie 객체```를 리턴하고 ```.value```로 ```getValue()```메서드를 호출한 것이다.    
그리고 만약 이름이 "ID"인 쿠키가 존재하지 않으면 EL의 특징으로 아무것도 출력하지 않는다.    
  
## 2.3. 객체 접근   
앞서 EL의 cookie 기본 객체에 대해서 사용을 했었다.  
```
${cookie.ID.value}
```
여기서 호기심이 많으신 분들은 무언가 궁금한 점을 느끼실 수 있다.     
첫번째로 cookie.ID를 어떻게 처리하는가?     
두번째로 cookie.ID의 결과 값은 JSP의 Cookie 객체인데 어떻게 .value를 사용 했는가이다.  
    
EL 언어는 객체에 저장된 값에 접근할 때 ```.```이나 ```[]```를 사용한다.  
이 두 연산자는 동일한 연산자로서 ```cookie.name``` 과 ```cookie['name']```은 같은 결과를 리턴한다.  
```
<표현1>.<표현2> 또는 <표현><[표현2]>
```

필자 : 참고로 JavaScript를 공부해보신 분들이라면 바로 무엇인지 감이 잡힐 수 있을 것이다.    
바로 JS 객체의 '프로퍼티' 라는 것이다.    
그래서 EL을 사용하는 경우 JSP 객체를 JS 객체의 프로퍼티처럼 사용한다고 생각하면 이해가 쉬울 것이다.     
(하지만 이는 필자가 생각하는 쉬운 방법이고 실제로는 다른 동작을 거친다. 이는 이해가 완벽히 되면 기술하겠다.)    
    
## 2.4. 객체 탐색   
EL 에서 PAGE, REQUEST, SESSION, APPLICATION 영역에 저장된 속성에 접근할 때,  
pageScope, requestScope, sessionScope, applicationScope 기본객체를 사용한다.  
```
${pageScope.NAME}
```
위 코드는 PAGE 영역에 저장된 NAME 이라는 속성의 값을 참고하는 것이다.   
  
영역을 나타내는 EL 기본 객체를 사용하지 않고 단순히 이름만 지정할 수 있는데  
이럴 경우 EL은 네 개의 영역을 차례대로 검색해서 속성이 존재하는지 확인한다.  
```
${NAME}
```
이 EL 요소는 ```PAGE -> REQUEST -> SESSION -> APPLICATION``` 영역을 차례대로 검사해서  
이름이 ```"NAME"```인 속성이 존재하는지 확인하고 존재하는 경우 그 속성의 값을 사용한다.  
물론 없으면 EL의 특징상 아무것도 나타내지 않는다.  
    
## 2.5. 수치 연산자 
수치 연산자는 6개가 있다.  
  
* + 연산자 : 덧셈
* - 연산자 : 뺄셈
* * 연산자 : 곱셈
* / 또는 div : 나눗셈
* % 또는 mod : 나머지
* - 단항 연산자 : 단항 뺄셈(음수)   
    
각 연산자의 의미는 기존에 알고 있는 개념과 동일하며 ```div``` 나 ```mod```를 추가적으로 사용할 수 있다.      
수치 연산자는 정수 타입과 실수 타입에 대해서만 동작하다.          
즉, 수치 타입과 객체(문자열)를 수치 연산자와 함께 사용하는 경우 해당 객체를 숫자로 변환한 후에 연산을 수행한다.      
```
${"10" + 1}
```
앞서 말했듯이 수치 연산자는 정수 타입과 실수 타입에 대해서만 동작하니 계산 결과는 11이다.  
```(이거는 개인적으로 헷갈려서 적어 놓는데 JavaScript 에서는 반대로 문자열 + 숫자 는 문자열 + 문자열이다.)```
```
${'일' + 10}
```
그리고 위 코드와 같이 숫자로 변환할 수 없는 객체와 수치 연산자를 함께 사용하면 에러가 발생한다.     
     
수치 연산자의 또다른 특징은 값이 null이면 0을 값으로 사용한다는 점이다.    
또, 정수 타입보다 실수 타입이 우선한다.    
(이부분도 이해가 완벽히 되면 기술하겠다.)   
      
## 2.6. 비교 연산자
EL이 제공하는 비교 연산자에는 6가지가 있다.  

* == 또는 eq
* != 또는 ne
* < 또는 lt
* > 또는 gt
* <= 또는 le
* >= 또는 ge  
  
숫자의 경우 자바 연산자와 동일한 방법으로 사용된다.  
문자열을 비교할 경우 ```String.compareTo()```메서드를 사용한다.
```
%{someValue == '2004'}
```
위 코드는 ```(someValue.compareTo("2004") == 0)```과 같은 의미를 지닌다.  
문자열 뿐만 아니라 객체도 compareTo() 메서드를 사용하여 객체가 같은 값을 갖는지를 비교한다.  
      
## 2.7. 논리 연산자
EL이 제공하는 논리 연산자에는 3가지가 있다.  
  
* && 또는 and
* || 또는 or
* ! 또는 not
  
이들 세 연산자는 자바 언어의 같은 연산자와 완전히 동일하다.    
      
## 2.8. empty 연산자
empty 연산자는 검색할 객체가 텅 빈 객체인지를 검사하기 위해 사용한다.  
```
empty <값>
```
여기서 <값>에 따라서 리턴되는 값은 다음과 같이 결정된다.  
  
1. <값>이 null 이면 true를 리턴한다.  
2. <값>이 빈 문자열("")이면 true를 리턴한다.  
3. <값>의 길이가 0인 배열이면 true를 리턴한다.  
4. <값>이 빈 Map이면 true를 리턴한다.
5. <값>이 빈 Collection이면 true를 리턴한다.  
6. 이외의 경우에는 false를 리턴한다.  
      
## 2.9. 비교 선택 연산자
비교 선택 연산자는 다음과 같다.
```
<수식> ? <값1> : <값2>
```
```<수식>```의 결과값이 ```true``` 이면 ```<값1>```을 리턴하고 ```false``` 이면```<값2>``` 리턴한다.
      
## 2.10. 문자열 연결
자바에서는 ```"문자열" + "문자열"```의 계산은 ```String``` 타입의 양쪽의 문자열을 연결시킨 값이다.  
하지만 EL 에서 덧셈은 수치형 데이터만을 계산하니 에러가 발생하여 문자열 연결을 할 수 없다.  
   
그러나 ```EL 3.0 버전```에서 문자열 연결을 위한 ```+=``` 연산자가 추가되었다.
```
${"문자" += "열" += "연결"}  <!--"문자열연결"-->
<% request.setAttribute("title", "JSP 프로그래밍"); %>
${"제목 :" += title}  <!--"제목 :JSP 프로그래밍" 그리고 title만 쓴 것은 탐색을 이용한 것이다.--> 
```
참고로 ```EL 3.0 버전```을 지원하는 JSP 버전은 2.3이다.  
      
## 2.10. 문자열 연결
